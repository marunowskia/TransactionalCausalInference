package oss.marunowskia.datamining.transactionalcausalinference.demo;

import java.beans.EventSetDescriptor;

import org.apache.log4j.Logger;

import oss.marunowskia.datamining.transactionalcausalinference.utilities.sequences.SequenceAnalyzer;


// Apologies if this part is messy. I may have sacrificed sleep to sneak writing this into my schedule
public class FixedSequenceDemo {
	
	private static final double FIXED_SEQUENCE_PROBABILITY = 0.1;
	private static final int NUMBER_OF_EVENT_TYPES = 500;
	
	Logger logger = Logger.getLogger(FixedSequenceDemo.class);
	long[] fixedSequence = {4,4,4,4,4,4,4,1,2,3,4,5,6,7,8,9};
	
	/**
	 * Run a basic demo which contains both the expected sequence and unexpected sequence.
	 * The strongest association rule for this should be very close to 100% confident, 
	 * as there is a well defined pattern that it should be able to find.
	 * 
	 * @param demoSequenceLength
	 */
	public synchronized void runDemo(int demoSequenceLength) {
		
		SequenceAnalyzer sequenceAnalyzer = new SequenceAnalyzer();
		
		// Somewhat optimized parameters, based on our knowledge of the input data
		sequenceAnalyzer.setHistoryLimit(fixedSequence.length*2);
		sequenceAnalyzer.setRuleDepthLimit(fixedSequence.length);
		sequenceAnalyzer.setSupportThreshold((int)(demoSequenceLength/fixedSequence.length*FIXED_SEQUENCE_PROBABILITY*FIXED_SEQUENCE_PROBABILITY));
		
		for(int repeat = 0; repeat < demoSequenceLength/fixedSequence.length; repeat++) {
			if(Math.random()<FIXED_SEQUENCE_PROBABILITY) {
				// Simulates observing a defined sequence of events, and always getting the same result for the last event in that sequence
				playFixedSequence(sequenceAnalyzer);
			}
			else {
				playRandomSequence(sequenceAnalyzer);
			}
		}
		sequenceAnalyzer.reportAssociationRules();
	}

	private int eventId = 0;
	private void playFixedSequence(SequenceAnalyzer sequenceAnalyzer) {
		for(int a=0; a<fixedSequence.length; a++) {
			long event = fixedSequence[a];

			// Insert interruptions into the sequence being analyzed
			if(Math.random()<0.1) {
				sequenceAnalyzer.recordEvent(++eventId, (long)(Math.random()*100));
				sequenceAnalyzer.analyzeEvent(eventId, Math.random()<0.01);
			}
			
			sequenceAnalyzer.recordEvent(++eventId, event);
			if(a!=fixedSequence.length-1) {
				// Randomize the class label of the non-target sequence termination events
				sequenceAnalyzer.analyzeEvent(eventId, Math.random()<0.1);
			}
			else {
				sequenceAnalyzer.analyzeEvent(eventId, true);
			}
		}
	}
	
	private void playRandomSequence(SequenceAnalyzer sequenceAnalyzer) {
		for(int a=0; a<fixedSequence.length; a++) {
			long event = (long)(Math.random()*NUMBER_OF_EVENT_TYPES);
			sequenceAnalyzer.recordEvent(++eventId, event);
			sequenceAnalyzer.analyzeEvent(eventId, Math.random()<0.1);
		}
		
		
	}
}
